# ============================================================
# CD Pipeline — Deploy to Yandex Cloud
# ============================================================
# Триггер: push тега v*.*.* (после успешного CI)
# Пайплайн: Build → Push to Yandex CR → SSH Deploy → Health Check → Notify
# ============================================================

name: CD

on:
  push:
    tags:
      - "v*.*.*"
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag to deploy (e.g. v0.4.0)"
        required: true

permissions:
  contents: read

env:
  CR_REGISTRY: cr.yandex/${{ secrets.YC_CR_REGISTRY_ID }}
  IMAGE_NAME: vkuswill-bot
  DEPLOY_USER: deploy
  DEPLOY_DIR: /opt/vkuswill-bot

jobs:
  # ─── 1. Тесты (быстрая проверка перед деплоем) ────────────────
  test:
    name: Pre-deploy tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: astral-sh/setup-uv@v4
        with:
          version: "latest"

      - run: uv python install 3.12

      - run: uv sync --all-extras

      - name: Run tests
        run: uv run pytest -x -q --tb=short

  # ─── 2. Сборка и push Docker-образа ───────────────────────────
  build-and-push:
    name: Build & Push to Yandex CR
    runs-on: ubuntu-latest
    needs: test
    outputs:
      image_tag: ${{ steps.meta.outputs.tag }}
      full_image: ${{ steps.meta.outputs.full_image }}

    steps:
      - uses: actions/checkout@v4

      - name: Extract tag
        id: meta
        run: |
          TAG="${{ github.event.inputs.tag || github.ref_name }}"
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          echo "full_image=${CR_REGISTRY}/${IMAGE_NAME}:${TAG}" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Yandex Container Registry
        run: |
          echo '${{ secrets.YC_CR_KEY_SECRET }}' | \
            docker login cr.yandex \
              --username json_key \
              --password-stdin

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ steps.meta.outputs.full_image }}
            ${{ env.CR_REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Image digest
        run: echo "Pushed ${{ steps.meta.outputs.full_image }}"

  # ─── 3. Деплой на VM через SSH ────────────────────────────────
  deploy:
    name: Deploy to VM
    runs-on: ubuntu-latest
    needs: build-and-push
    environment: production

    steps:
      - uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VM_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H "${{ secrets.VM_HOST }}" >> ~/.ssh/known_hosts 2>/dev/null

      - name: Copy deploy script
        run: |
          scp -i ~/.ssh/deploy_key deploy/deploy.sh "${{ env.DEPLOY_USER }}@${{ secrets.VM_HOST }}:${{ env.DEPLOY_DIR }}/deploy.sh"

      - name: Docker login on VM
        run: |
          echo '${{ secrets.YC_CR_KEY_SECRET }}' | ssh -i ~/.ssh/deploy_key "${{ env.DEPLOY_USER }}@${{ secrets.VM_HOST }}" "docker login cr.yandex --username json_key --password-stdin"

      - name: Prepare .env on VM
        env:
          _BOT_TOKEN: ${{ secrets.BOT_TOKEN }}
          _GIGACHAT_CRED: ${{ secrets.GIGACHAT_CREDENTIALS }}
          _GIGACHAT_MODEL: ${{ secrets.GIGACHAT_MODEL }}
          _WEBHOOK_HOST: ${{ secrets.WEBHOOK_HOST || secrets.VM_HOST }}
          _S3_LOG_BUCKET: ${{ secrets.S3_LOG_BUCKET }}
          _S3_LOG_ACCESS_KEY: ${{ secrets.S3_LOG_ACCESS_KEY }}
          _S3_LOG_SECRET_KEY: ${{ secrets.S3_LOG_SECRET_KEY }}
          _LANGFUSE_ENABLED: ${{ secrets.LANGFUSE_ENABLED }}
          _LANGFUSE_PUBLIC_KEY: ${{ secrets.LANGFUSE_PUBLIC_KEY }}
          _LANGFUSE_SECRET_KEY: ${{ secrets.LANGFUSE_SECRET_KEY }}
          _LANGFUSE_DATABASE_URL: ${{ secrets.LANGFUSE_DATABASE_URL }}
          _LANGFUSE_NEXTAUTH_SECRET: ${{ secrets.LANGFUSE_NEXTAUTH_SECRET }}
          _LANGFUSE_SALT: ${{ secrets.LANGFUSE_SALT }}
        run: |
          {
            echo "BOT_TOKEN=${_BOT_TOKEN}"
            echo "GIGACHAT_CREDENTIALS=${_GIGACHAT_CRED}"
            echo "GIGACHAT_MODEL=${_GIGACHAT_MODEL:-GigaChat}"
            echo "WEBHOOK_HOST=${_WEBHOOK_HOST}"
            echo "USE_WEBHOOK=true"
            echo "WEBHOOK_PORT=8080"
            # S3 логирование
            if [ -n "$_S3_LOG_BUCKET" ]; then
              echo "S3_LOG_ENABLED=true"
              echo "S3_LOG_BUCKET=${_S3_LOG_BUCKET}"
              echo "S3_LOG_ACCESS_KEY=${_S3_LOG_ACCESS_KEY}"
              echo "S3_LOG_SECRET_KEY=${_S3_LOG_SECRET_KEY}"
            fi
            # Langfuse (self-hosted)
            if [ -n "$_LANGFUSE_ENABLED" ]; then
              echo "LANGFUSE_ENABLED=${_LANGFUSE_ENABLED}"
              echo "LANGFUSE_HOST=http://localhost:3000"
              echo "LANGFUSE_PUBLIC_KEY=${_LANGFUSE_PUBLIC_KEY}"
              echo "LANGFUSE_SECRET_KEY=${_LANGFUSE_SECRET_KEY}"
              echo "LANGFUSE_DATABASE_URL=${_LANGFUSE_DATABASE_URL}"
              echo "LANGFUSE_NEXTAUTH_SECRET=${_LANGFUSE_NEXTAUTH_SECRET}"
              echo "LANGFUSE_SALT=${_LANGFUSE_SALT}"
            fi
          } | ssh -i ~/.ssh/deploy_key "${{ env.DEPLOY_USER }}@${{ secrets.VM_HOST }}" \
            "cat > ${{ env.DEPLOY_DIR }}/.env && chmod 600 ${{ env.DEPLOY_DIR }}/.env"

      - name: Run deploy
        run: |
          FULL_IMAGE="${{ env.CR_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build-and-push.outputs.image_tag }}"
          ssh -i ~/.ssh/deploy_key "${{ env.DEPLOY_USER }}@${{ secrets.VM_HOST }}" "bash ${{ env.DEPLOY_DIR }}/deploy.sh --image '${FULL_IMAGE}' --tag '${{ needs.build-and-push.outputs.image_tag }}' --lockbox '${{ secrets.LOCKBOX_SECRET_ID }}'"

      - name: Health check
        timeout-minutes: 3
        env:
          _VM_HOST: ${{ secrets.VM_HOST }}
        run: |
          # Проверяем через nginx (HTTPS, self-signed) или напрямую
          HEALTH_URL="https://${_VM_HOST}/health"
          echo "Health check URL: ${HEALTH_URL}"
          echo "Ожидание запуска бота (30 сек)..."
          sleep 30
          for i in 1 2 3 4 5; do
            STATUS=$(curl -sk --connect-timeout 5 --max-time 10 -o /dev/null -w "%{http_code}" "${HEALTH_URL}" 2>/dev/null || \
                     curl -s --connect-timeout 5 --max-time 10 -o /dev/null -w "%{http_code}" "http://${_VM_HOST}:8080/health" 2>/dev/null || echo "000")
            if [ "$STATUS" = "200" ]; then
              echo "Health check OK (attempt $i)"
              exit 0
            fi
            echo "Attempt $i: status=$STATUS, retrying in 10s..."
            sleep 10
          done
          echo "::warning::Health check failed after 5 attempts"

      - name: Cleanup SSH
        if: always()
        run: rm -f ~/.ssh/deploy_key

  # ─── 4. Уведомление в Telegram ────────────────────────────────
  notify:
    name: Notify
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy]
    if: always()

    steps:
      - name: Send Telegram notification
        env:
          BOT_TOKEN: ${{ secrets.BOT_TOKEN }}
          CHAT_ID: ${{ secrets.ADMIN_CHAT_ID }}
          TAG: ${{ needs.build-and-push.outputs.image_tag }}
          DEPLOY_STATUS: ${{ needs.deploy.result }}
        run: |
          if [ -z "$BOT_TOKEN" ]; then
            echo "BOT_TOKEN не задан, пропускаем уведомление"
            exit 0
          fi

          if [ "$DEPLOY_STATUS" = "success" ]; then
            EMOJI="✅"
            TEXT="Деплой ${TAG} завершён успешно"
          else
            EMOJI="❌"
            TEXT="Деплой ${TAG} завершился с ошибкой: ${DEPLOY_STATUS}"
          fi

          MESSAGE="${EMOJI} <b>VkusVill Bot Deploy</b>%0A%0A${TEXT}%0ARepo: ${GITHUB_REPOSITORY}%0ACommit: ${GITHUB_SHA:0:7}"

          curl -s -X POST \
            "https://api.telegram.org/bot${BOT_TOKEN}/sendMessage" \
            -d "chat_id=${CHAT_ID}" \
            -d "text=${MESSAGE}" \
            -d "parse_mode=HTML" \
            > /dev/null 2>&1 || true

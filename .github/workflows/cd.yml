# ============================================================
# CD Pipeline — Deploy to Yandex Cloud
# ============================================================
# Триггер: push тега v*.*.* (после успешного CI)
# Пайплайн: Build → Push to Yandex CR → SSH Deploy → Health Check → Notify
# ============================================================

name: CD

on:
  push:
    tags:
      - "v*.*.*"
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag to deploy (e.g. v0.4.0)"
        required: true

permissions:
  contents: read

env:
  CR_REGISTRY: cr.yandex/${{ secrets.YC_CR_REGISTRY_ID }}
  IMAGE_NAME: vkuswill-bot
  DEPLOY_USER: deploy
  DEPLOY_DIR: /opt/vkuswill-bot

jobs:
  # ─── 1. Тесты (быстрая проверка перед деплоем) ────────────────
  test:
    name: Pre-deploy tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: astral-sh/setup-uv@v4
        with:
          version: "latest"

      - run: uv python install 3.12

      - run: uv sync --all-extras

      - name: Run tests
        run: uv run pytest -x -q --tb=short

  # ─── 2. Сборка и push Docker-образа ───────────────────────────
  build-and-push:
    name: Build & Push to Yandex CR
    runs-on: ubuntu-latest
    needs: test
    outputs:
      image_tag: ${{ steps.meta.outputs.tag }}
      full_image: ${{ steps.meta.outputs.full_image }}

    steps:
      - uses: actions/checkout@v4

      - name: Extract tag
        id: meta
        run: |
          TAG="${{ github.event.inputs.tag || github.ref_name }}"
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          echo "full_image=${CR_REGISTRY}/${IMAGE_NAME}:${TAG}" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Yandex Container Registry
        run: |
          echo '${{ secrets.YC_CR_KEY_SECRET }}' | \
            docker login cr.yandex \
              --username json_key \
              --password-stdin

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ steps.meta.outputs.full_image }}
            ${{ env.CR_REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Image digest
        run: echo "Pushed ${{ steps.meta.outputs.full_image }}"

  # ─── 3. Деплой на VM через SSH ────────────────────────────────
  deploy:
    name: Deploy to VM
    runs-on: ubuntu-latest
    needs: build-and-push
    environment: production

    steps:
      - uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VM_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H "${{ secrets.VM_HOST }}" >> ~/.ssh/known_hosts 2>/dev/null

      - name: Copy deploy script
        run: |
          scp -i ~/.ssh/deploy_key deploy/deploy.sh "${{ env.DEPLOY_USER }}@${{ secrets.VM_HOST }}:${{ env.DEPLOY_DIR }}/deploy.sh"

      - name: Docker login on VM
        run: |
          # Убрать yc credential helper из Docker config (если остался от предыдущих деплоев)
          ssh -i ~/.ssh/deploy_key "${{ env.DEPLOY_USER }}@${{ secrets.VM_HOST }}" \
            "rm -f ~/.docker/config.json" 2>/dev/null || true
          echo '${{ secrets.YC_CR_KEY_SECRET }}' | ssh -i ~/.ssh/deploy_key "${{ env.DEPLOY_USER }}@${{ secrets.VM_HOST }}" "docker login cr.yandex --username json_key --password-stdin"

      - name: Prepare fallback .env on VM
        env:
          _BOT_TOKEN: ${{ secrets.BOT_TOKEN }}
          _GIGACHAT_CRED: ${{ secrets.GIGACHAT_CREDENTIALS }}
          _WEBHOOK_HOST: ${{ secrets.WEBHOOK_HOST || secrets.VM_HOST }}
          _LF_ENABLED: ${{ secrets.LANGFUSE_ENABLED }}
          _LF_DB_URL: ${{ secrets.LANGFUSE_DATABASE_URL }}
          _LF_AUTH_SECRET: ${{ secrets.LANGFUSE_NEXTAUTH_SECRET }}
          _LF_SALT: ${{ secrets.LANGFUSE_SALT }}
          _LF_PUBLIC_KEY: ${{ secrets.LANGFUSE_PUBLIC_KEY }}
          _LF_SECRET_KEY: ${{ secrets.LANGFUSE_SECRET_KEY }}
          _LF_HOST: ${{ secrets.LANGFUSE_HOST }}
        run: |
          # Фоллбэк: минимальный .env на случай если yc CLI / Lockbox недоступны.
          # deploy.sh перезапишет .env из Lockbox, если yc CLI установлен.
          {
            echo "BOT_TOKEN=${_BOT_TOKEN}"
            echo "GIGACHAT_CREDENTIALS=${_GIGACHAT_CRED}"
            echo "GIGACHAT_MODEL=GigaChat-2-Max"
            echo "WEBHOOK_HOST=${_WEBHOOK_HOST}"
            echo "USE_WEBHOOK=true"
            echo "WEBHOOK_PORT=8080"
            echo "LANGFUSE_ENABLED=${_LF_ENABLED:-false}"
            echo "LANGFUSE_HOST=${_LF_HOST:-http://localhost:3000}"
            echo "LANGFUSE_DATABASE_URL=${_LF_DB_URL}"
            echo "LANGFUSE_NEXTAUTH_SECRET=${_LF_AUTH_SECRET}"
            echo "LANGFUSE_SALT=${_LF_SALT}"
            echo "LANGFUSE_PUBLIC_KEY=${_LF_PUBLIC_KEY}"
            echo "LANGFUSE_SECRET_KEY=${_LF_SECRET_KEY}"
          } | ssh -i ~/.ssh/deploy_key "${{ env.DEPLOY_USER }}@${{ secrets.VM_HOST }}" \
            "cat > ${{ env.DEPLOY_DIR }}/.env && chmod 600 ${{ env.DEPLOY_DIR }}/.env"

      - name: Run deploy
        run: |
          FULL_IMAGE="${{ env.CR_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build-and-push.outputs.image_tag }}"
          ssh -i ~/.ssh/deploy_key "${{ env.DEPLOY_USER }}@${{ secrets.VM_HOST }}" "bash ${{ env.DEPLOY_DIR }}/deploy.sh --image '${FULL_IMAGE}' --tag '${{ needs.build-and-push.outputs.image_tag }}' --lockbox '${{ secrets.LOCKBOX_SECRET_ID }}' --model 'GigaChat-2-Max'"

      - name: Container diagnostics
        if: always()
        run: |
          echo "=== Bot container logs (last 50) ==="
          ssh -i ~/.ssh/deploy_key "${{ env.DEPLOY_USER }}@${{ secrets.VM_HOST }}" \
            "docker logs vkuswill-bot --tail 50 2>&1" || true
          echo ""
          echo "=== Langfuse container status ==="
          ssh -i ~/.ssh/deploy_key "${{ env.DEPLOY_USER }}@${{ secrets.VM_HOST }}" \
            "docker ps -a -f name=vkuswill-langfuse --format '{{.Status}}' && echo '--- logs ---' && docker logs vkuswill-langfuse --tail 20 2>&1" || true

      - name: Health check
        timeout-minutes: 3
        env:
          _VM_HOST: ${{ secrets.VM_HOST }}
        run: |
          # Проверяем через nginx (HTTPS) или напрямую (HTTP)
          HTTPS_URL="https://${_VM_HOST}/health"
          HTTP_URL="http://${_VM_HOST}:8080/health"
          echo "Health check URLs: ${HTTPS_URL} / ${HTTP_URL}"
          echo "Ожидание запуска бота (30 сек)..."
          sleep 30
          for i in 1 2 3 4 5; do
            # Попытка HTTPS (self-signed → -k)
            STATUS=$(curl -sk --connect-timeout 5 --max-time 10 -o /dev/null -w "%{http_code}" "${HTTPS_URL}" 2>/dev/null) || true
            if [ "$STATUS" = "200" ]; then
              echo "Health check OK via HTTPS (attempt $i)"
              exit 0
            fi
            # Фоллбэк на HTTP напрямую
            STATUS=$(curl -s --connect-timeout 5 --max-time 10 -o /dev/null -w "%{http_code}" "${HTTP_URL}" 2>/dev/null) || true
            if [ "$STATUS" = "200" ]; then
              echo "Health check OK via HTTP (attempt $i)"
              exit 0
            fi
            echo "Attempt $i: HTTPS/HTTP status=$STATUS, retrying in 10s..."
            sleep 10
          done
          echo "::warning::Health check failed after 5 attempts"

      - name: Register Langfuse models
        if: success()
        run: |
          # Скрипт читает LANGFUSE_PUBLIC_KEY, LANGFUSE_SECRET_KEY, LANGFUSE_HOST
          # из env-переменных контейнера (переданных через .env)
          ssh -i ~/.ssh/deploy_key "${{ env.DEPLOY_USER }}@${{ secrets.VM_HOST }}" \
            "docker exec vkuswill-bot python scripts/setup_langfuse_models.py --force" \
            2>&1 || echo "::warning::Langfuse model registration failed (non-critical)"

      - name: Cleanup SSH
        if: always()
        run: rm -f ~/.ssh/deploy_key

  # ─── 4. Уведомление в Telegram ────────────────────────────────
  notify:
    name: Notify
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy]
    if: always()

    steps:
      - name: Send Telegram notification
        env:
          BOT_TOKEN: ${{ secrets.BOT_TOKEN }}
          CHAT_ID: ${{ secrets.ADMIN_CHAT_ID }}
          TAG: ${{ needs.build-and-push.outputs.image_tag }}
          DEPLOY_STATUS: ${{ needs.deploy.result }}
        run: |
          if [ -z "$BOT_TOKEN" ]; then
            echo "BOT_TOKEN не задан, пропускаем уведомление"
            exit 0
          fi

          if [ "$DEPLOY_STATUS" = "success" ]; then
            EMOJI="✅"
            TEXT="Деплой ${TAG} завершён успешно"
          else
            EMOJI="❌"
            TEXT="Деплой ${TAG} завершился с ошибкой: ${DEPLOY_STATUS}"
          fi

          MESSAGE="${EMOJI} <b>VkusVill Bot Deploy</b>%0A%0A${TEXT}%0ARepo: ${GITHUB_REPOSITORY}%0ACommit: ${GITHUB_SHA:0:7}"

          curl -s -X POST \
            "https://api.telegram.org/bot${BOT_TOKEN}/sendMessage" \
            -d "chat_id=${CHAT_ID}" \
            -d "text=${MESSAGE}" \
            -d "parse_mode=HTML" \
            > /dev/null 2>&1 || true
